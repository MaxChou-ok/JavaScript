<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
/*
    函数的三种角色
1.function fn(){}
函数：能够调用的角色
2.构造函数
 new 构造对象的
 fn.prototype 公共的属性或方法挂在这个构造函数的原型下
3.Function的实例
new Function -> function(){}
在函数的原型下有一个属性，constructor，指向构造函数，但仅仅是一个指向构造函数的方向，非常容易被修改
Fn.prototype = {}
**注意 在对象赋值给构造函数原型的时候，constructor指向会被修改，指向的是Object，所以需要手动修正constructor指向
Fn.prototype = { constructor:Fn }
*/

// 例子  预解析
// function Fn(){
//     this.x = 100;
//     this.y = 200;
//     this.getX = function(){
//         console.log(this.x);
//     }
// }
// Fn.prototype ={
//     y:400,
//     getX:function(){
//         console.log(this.x);
//     },
//     getY:function(){
//         console.log(this.y)
//     },
//     sum:function(){
//         console.log(this.x + this.y);
//     }
// };
//       var f1 = new Fn();
//       var f2 = new Fn;
//         console.log(f1.getX === f2.getX); //f
//         console.log(f1.getY === f2.getY); //t
//         console.log(f1.__proto__.getY === Fn.prototype.getY); //t
//         console.log(f1.__proto__.getX === f2.getX); //f
//         console.log(f1.getX === Fn.prototype.getX); //f
//         console.log(f1.constructor);
//         // Fn.prototype = {__proto__:Object}
//         console.log(Fn.prototype.__proto__.constructor); //Object
//         f1.getX(); //100
//         f1.__proto__.getX(); //undefined  
//         f1.__proto__.getY(); //400
//         f2.getY();//200
//         Fn.prototype.getY();//400
//         f1.sum();//300
//         Fn.prototype.sum();//NaN  

// function Person(){
//     this.name='zf'
// };
// Person.prototype.getName=function(){
//     console.log(this.name)
//     console.log(this.age)
// };
// Person.prototype.age=50;
// var per1 = new Person;
// per1.getName(); //5000
// per1.age=9;
// per1.getName(); //9
// console.log(per1.age); //9
// var per2 = new Person; 
// console.log(per2.age) //5000

/*
1.window
            全局打印this
            函数 + 括号
            定时器
            (function(){})()

2.事件触发的元素
            只要是事件函数内的this都指向事件触发的元素

3.点前面的主
4.实例
            构造函数下的this是实例   new Fn
            构造函数原型的this也是实例 (实例调用)
            Fn.prototype.say()  this为Fn.prototype
5.箭头函数
            指向的是声明箭头函数的上下文this
            没有arguments，不能new

改写this
函数创建时天生自带的方法 call apply bind
call：
第一个参数：修改this指向
第二个指向：函数的实参
apply：
第一个参数：
修改this指向
第二个参数：
数组，里面放的是实参
bind:(惰性函数，柯里化函数，高阶函数)
多个参数
第一个参数：修改this指向
第二个参数及之后：函数的实参

返回的是新函数，只要调用返回的函数才能执行函数内的代码
都是改变this指向的方法
细节：在使用它们修改this指向的时候，传undefined和null还是默认的window
*/

// hasOwnProperty 查看某个属性是不是对象自身的
// 返回一个布尔值 ：是自身的属性就是true，否则false
//   用法:
//     for in的时候会枚举原型，会把自定义的属性或者方法枚举出来
//     查看某个属性或者方法是否为对象自身的（面向对象中）即查看某个属性是公有的还私有的

//     在for in的过程当中，如果不能确定构造函数的原型下是否有自定义的属性或者方法
//     那么建议加一个if判断，判断枚举的属性都是自身的
</script>
</body>
</html>